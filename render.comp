#version 310 es

// references:
// https://github.com/oktomus/web-experiments/blob/1e2d3bfbe6/webgl-compute/toy-raytracer/glsl/render.glsl
// http://three-eyed-games.com/2018/05/03/gpu-ray-tracing-in-unity-part-1/

precision highp float;
precision highp int;
precision mediump image2DArray;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (rgba8, binding = 0) writeonly uniform highp image2D frameTex;
layout (rgba8, binding = 1) readonly uniform highp image2D accumulatedTex;

#define EPSILON 0.001
#define MAX_FLOAT 3.402823466e+30F
#define M_PI 3.14159265358979323846
#define M_TWO_PI 6.28318530718

const vec3 zero3 = vec3(0.0);

// describe a mesh object
struct Mesh {
  // number of faces
  // face_count == -1: a sphere
  int face_count;
  // the starting index in the vertice array
  int offset;
  // emit itensity
  float intensity;
  // specular exponent
  float alpha;
  // emit light color
  vec3 emission;
  vec3 color;
  vec3 specular;
};

layout(std430, binding = 0) readonly buffer Vertices {
  vec3 vertices[];
};

layout(std430, binding = 1) readonly buffer Meshes {
  Mesh meshes[];
};

layout(std430, binding = 2) buffer Diff {
  float diff;
};

uniform float uSeed;
uniform int uRenderTimes;

uniform mat4 uViewInverse;
uniform mat4 uProjectionInverse;

uniform vec3 uAmbient;

//
// Pseudo random numbers generator.
//
// References:
// - http://blog.three-eyed-games.com/2018/05/12/gpu-path-tracing-in-unity-part-2/
//
// the random number should be unique for different sensor pixel
float rand(inout float seed, vec2 pixel)
{
    float result = fract(sin(seed / 100.0f * dot(pixel, vec2(12.9898f, 78.233f))) * 43758.5453f);
    seed += 1.0f;
    return result;
}

vec2 rand2(inout float seed, vec2 pixel)
{
    return vec2(rand(seed, pixel), rand(seed, pixel));
}

// Ray
struct Ray {
  vec3 origin;
  vec3 dir;
  vec3 energy;
};

vec3 hit_at(Ray r, float t) {
  return r.origin + r.dir * t;
}

// MÃ¶ller-Trumbore algorithm for triangle interception
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection

bool hit_triangle_at(Ray r, vec3 a, vec3 b, vec3 c, out float at) {
  vec3 d = r.dir;
  vec3 ab = b - a;
  vec3 ac = c - a;

  vec3 p = cross(d, ac);

  float denominator = dot(p, ab);

  // The ray direction and the surface normal are perpendicular
  // Allow both side of a triangle be intercepted.
  if (denominator < EPSILON) return false;

  vec3 t = r.origin - a;

  vec3 q = cross(t, ab);

  float invDenom = 1.0 / denominator;

  float u = dot(p, t) * invDenom;

  if (u < 0.0 || u > 1.0) return false;

  float v = dot(q, d) * invDenom;
  if (v < 0.0 || v + u > 1.0) return false;

  at = dot(q, ac) * invDenom;

  // the interpceted point is behind the camera
  if (at < EPSILON) {
    return false;
  }

  return true;
}

// reference http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/
bool hit_sphere(Ray r, vec3 center, float radius, out float at) {
  vec3 d = r.origin - center;
  float a = dot(r.dir, r.dir);
  float b = 2.0 * dot(r.dir, d);
  float c = dot(d, d) - radius * radius;

  float discriminant = b * b - 4.0 * a * c;
  
  if (discriminant < 0.0) {
    at = 0.0;
    return false;
  } else {
    // we only take the nearest interception point
    at = -(b + sqrt(discriminant)) / 2.0 / a;
    return true;
  }
}

// get a random point on an unit sphere
// reference: http://corysimon.github.io/articles/uniformdistn-on-sphere/
vec3 sample_sphere_uniform(inout float seed, vec2 pixel) {
  vec2 s = rand2(seed, pixel);
  
  float theta = M_TWO_PI * s.x;
  float cos_phi = 1.0 - 2.0 * s.y;
  float sin_phi = sqrt(1.0 - cos_phi * cos_phi);

  return vec3(
      cos(theta) * sin_phi,
      cos_phi,
      sin(theta) * sin_phi);
}

mat3 get_tengent_space(vec3 normal) {
  // Choose a helper vector for the cross product
  vec3 helper = vec3(1, 0, 0);
  if (abs(normal.x) > 0.99) {
    helper = vec3(0, 0, 1);
  }

  // Generate vectors
  vec3 tangent = normalize(cross(normal, helper));
  vec3 binormal = normalize(cross(normal, tangent));

  return mat3(tangent, binormal, normal);
}

vec3 sample_hemisphere_uniform(vec3 normal, float alpha, inout float seed, vec2 pixel) {
  vec2 r = rand2(seed, pixel);
  float sin_theta = 1.0 - pow(1.0 - r.x, 2.0 / (1.0 + alpha));
  float cos_theta = sqrt(1.0 - sin_theta);
  sin_theta = sqrt(sin_theta);

  float phi = r.y * M_TWO_PI;

  vec3 dir = vec3(
    sin_theta * cos(phi),
    sin_theta * sin(phi),
    cos_theta
  );

  return get_tengent_space(normal) * dir;
}

// use berymetric coordinate to get a random point on a mesh
vec3 random_point_on_mesh(Mesh m, inout float seed, vec2 pixel) {
  if (m.face_count == -1) {
    vec3 center = vertices[m.offset];
    vec3 normal = vertices[m.offset + 1];

    return center + length(normal) * sample_sphere_uniform(seed, pixel);
  }

  // pick a random face 
  int face_index = min(int(rand(seed, pixel) * float(m.face_count)), m.face_count - 1);
  int index = face_index + m.offset;
  
  vec3 a = vertices[index + 0];
  vec3 b = vertices[index + 1];
  vec3 c = vertices[index + 2];

  float u = rand(seed, pixel);
  float v = rand(seed, pixel);

  if (u + v > 1.0) {
    u = 1.0 - u;
    v = 1.0 - v;
  }

  float t = 1.0 - u - v;

  return a * t + b * u + c * v;
}

bool hit_mesh(Ray r, float at_min, float at_max, inout float at, out int index, out vec3 normal) {
  index = -1;
  at = at_max;
  bool hit = false;

  for (int i = 0; i < meshes.length(); ++i) {
    Mesh mesh = meshes[i];
    int offset = mesh.offset;
    float t;

    if (mesh.face_count == -1) {
      vec3 a = vertices[offset];
      vec3 b = vertices[offset + 1];

      if (hit_sphere(r, a, length(b), t) && t >= at_min && t < at_max && t < at) {
        hit = true; 
        at = t;
        index = i;
        normal = normalize(hit_at(r, t) - a);
      }
    } else {
      for (int j = 0; j < mesh.face_count; ++j) {

        vec3 a = vertices[j * 3 + offset ];
        vec3 b = vertices[j * 3 + offset + 1];
        vec3 c = vertices[j * 3 + offset + 2];

        if (hit_triangle_at(r, a, b, c, t) && t >= at_min && t < at_max && t < at) {
          hit = true; 
          at = t;
          index = i;
          normal = normalize(cross(b - a, c - a));
        }
      }
    }
  }

  return hit;
}

vec3 reflect_dir(vec3 normal, vec3 dir) {
  return normalize(2.0 * dot(normal, -dir) * normal + dir);
}

const int max_depth = 5;
// get the color of a ray
vec3 get_color(Ray r, inout float seed, vec2 pixel) {
  int depth = 0;
  float at;
  int mesh_index;
  vec3 normal;
  vec3 ret = vec3(0.0);

  while (depth < max_depth && length(r.energy) > EPSILON) {
    if (hit_mesh(r, 0.01, MAX_FLOAT, at, mesh_index, normal)) {

      Mesh mesh = meshes[mesh_index];
      vec3 surface_normal = normal;
      vec3 hit_point = hit_at(r, at);

      // the ray hit a light source
      if (mesh.emission != vec3(0.0)) {
        ret += max(r.energy * mesh.emission * mesh.intensity, vec3(1));
        r.energy = vec3(0.0);
      } else {
        // vec3 lightColor = vec3(0);
        // send shadow ray to all light sources
        // for (int i = 0; i < meshes.length(); i++) {
        //   Mesh light = meshes[i];
        //   if (light.emission != vec3(0.0)) {
        //     Ray shadow_ray;
        //     vec3 light_dir = random_point_on_mesh(light, seed, pixel) - hit_point;
        //     shadow_ray.origin = hit_point;
        //     shadow_ray.dir = normalize(light_dir);

        //     float dist = length(light_dir);

        //     // does not hit some mesh between the light source and the surface.
        //     if (!hit_mesh(shadow_ray, 0.01, dist, at, mesh_index, normal) || mesh_index == i) {
        //       lightColor += light.intensity * light.emission * mesh.color * max(0.0,  dot(surface_normal, shadow_ray.dir));
        //     }
        //   }
        // }

        // lightColor = min(lightColor, vec3(1));

        // ret += r.energy * lightColor;

        float diffuse_factor = dot(mesh.color, vec3(1.0/3.0));
        float specular_factor = dot(mesh.specular, vec3(1.0/3.0));
        float sum = diffuse_factor + specular_factor;
        diffuse_factor /= sum;
        specular_factor /= sum;

        float chance = rand(seed, pixel);

        r.origin = hit_point + 0.001 * surface_normal;
        if (chance < specular_factor) {
          r.dir = normalize(sample_hemisphere_uniform(reflect_dir(surface_normal, r.dir), mesh.alpha, seed, pixel));
          float f = (mesh.alpha + 2.0) / (mesh.alpha + 1.0);
          r.energy *= (1.0 / specular_factor) * mesh.specular * max(0.0, dot(surface_normal, r.dir) * f);
        } else {
          r.dir = normalize(sample_hemisphere_uniform(surface_normal, 1.0, seed, pixel));
          r.energy *= (1.0 / diffuse_factor) * mesh.color;
        }
      }
    } else {
      // hit nothing, we give an ambient light
      ret += r.energy * uAmbient;
      r.energy = vec3(0.0);
    }

    depth ++;
  }

  return ret / float(depth);
}

Ray create_camera_ray(vec2 uv) {
  vec3 origin = (uViewInverse * vec4(0, 0, 0, 1)).xyz;
  vec3 dir = (uProjectionInverse * vec4(uv, 0, 1)).xyz;
  dir = (uViewInverse * vec4(dir, 0)).xyz;
  dir = normalize(dir);

  Ray r;
  r.origin = origin;
  r.dir = dir;
  r.energy = vec3(1.0);
  return r;
}

void main() {
  // https://www.khronos.org/opengl/wiki/Compute_Shader/Defined_Inputs
  // gl_GlobalInvocationId = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;

  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
  ivec2 imageSize = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
  vec2 uv = vec2(storePos) / vec2(imageSize);
  float seed = uSeed;

  vec2 sample_pos = (vec2(storePos) + rand2(seed, uv)) / vec2(imageSize);

  Ray r = create_camera_ray(sample_pos);

  vec3 color = get_color(r, seed, uv);
  if (uRenderTimes != 0) {
    vec3 initColor = imageLoad(accumulatedTex, storePos).rgb;
    vec3 d = (color - initColor) / float(uRenderTimes);

    // output the frame difference
    diff += dot(d, d);

    color = initColor + d;
  } else {
    diff += 1.0;
  }

  imageStore(frameTex, storePos, vec4(color, 1.0));
}
